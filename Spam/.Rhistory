setwd(messagePaths[1])
setwd('~/Documents/GitRepos/RRepos/Spam')
dirMessageRoot = getwd()
dirNames = list.files(path=paste(dirMessageRoot,"Messages",sep=.Platform$file.sep))
messagePaths = paste(dirMessageRoot,"Message",dirNames,sep=.Platform$file.sep)
messagesList = list.files(path=messagePaths)
class(messagesList)
length(messagesList)
messagesList = list.files(messagePaths[1])
messagePaths[1]
messagePaths = paste(dirMessageRoot,"Messages",dirNames,sep=.Platform$file.sep)
messagesList = list.files(messagePaths[1])
print (length(messagesList))
messagesList = list.files(messagePaths)
print (length(messagesList))
print ("Message Data Files")
sapply(messagePaths, function(x)
print (paste(x,length(list.files(x))))
)
fileNames =list.files(messagePaths[1],full.names = TRUE)
fileNames[1]
head(msg)
msg = readLines(fileNames[1])
head(msg)
class(head)
class(msg)
length(msg)
source('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
emailIndecies = c(1:5, 15,27,68,69,329,404,427,516,852,971)  # emails from the easy_ham folder.
fn = list.files(messagePaths[1],full.names = TRUE)[emailIndicies] # get the fully qualified names of the sample emails
fn = list.files(messagePaths[1],full.names = TRUE)[emailIndecies] # get the fully qualified names of the sample emails
sampleEmails = sapply(fn, readLine)
sampleEmails = sapply(fn, readLines)
class(sampleEmails)
class(sampleEmails[[1]])
length(sampleEmails[[1]])
length(sampleEmails)
which("",msg)
which(msg,"")
help which
which(msg="")
which(msg=="")
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
try(boundary = which("",vEmail)[1], silent=TRUE)
if (boundary>-1){
head = vEmail[1:(boundary-1)]
bod = vEmail[-(1:boundar)]
return  (as.list(header = head,body=bod))
}
else
return (NULL)
}
a=severHeader(msg)
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
try(boundary = which(vEmail=="")[1], silent=TRUE)
if (boundary>-1){
head = vEmail[1:(boundary-1)]
bod = vEmail[-(1:boundar)]
return  (as.list(header = head,body=bod))
}
else
return (NULL)
}
a=severHeader(msg)
which(msg=="")
which(msg=="")[1]
boundary = which(msg=="")
boundary
try(boundary = which(msg==""),silent = TRUE)
try(which(msg==""),silent = TRUE)
try(which(msg=="")[1],silent = TRUE)
boundary = try(which(msg=="")[1],silent = TRUE)
boundary
boundary = try(which(msg=="asdf")[1],silent = TRUE)
boundary
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
boundary = try(which(vEmail=="")[1], silent=TRUE)
if (!is.na(boundary)){
head = vEmail[1:(boundary-1)]
bod = vEmail[-(1:boundar)]
return  (as.list(header = head,body=bod))
}
else
stop()
}
a= severHeader(msg)
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
boundary = try(which(vEmail=="")[1], silent=TRUE)
if (!is.na(boundary)){
head = vEmail[1:(boundary-1)]
bod = vEmail[-(1:boundary)]
return  (as.list(header = head,body=bod))
}
else
stop()
}
a= severHeader(msg)
a= severHeader(msg)
a= severHeader(msg)
head
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
boundary = try(which(vEmail=="")[1], silent=TRUE)
if (!is.na(boundary)){
eHead = vEmail[1:(boundary-1)]
eBod = vEmail[-(1:boundary)]
return  (as.list(header = eHead,body=eBod))
}
else
stop()
}
a= severHeader((msg))
a= severHeader((msg))
eHead
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
a = severHeader(msg)
boundary
eHead
eBod
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
boundary = try(which(vEmail=="")[1], silent=TRUE)
if (!is.na(boundary)){
eHead = vEmail[1:(boundary-1)]
eBod = vEmail[-(1:boundary)]
ret =  as.list(header = eHead,body=eBod)
return  (ret)
}
else
stop()
}
severHeader(msg)
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
boundary = try(which(vEmail=="")[1], silent=TRUE)
if (!is.na(boundary)){
eHead = vEmail[1:(boundary-1)]
eBod = vEmail[-(1:boundary)]
ret =  as.list((header = eHead,body=eBod))
return  (ret)
}
else
stop()
}
a = list(d='test',f='fcol')
list(header='a',body='b')
a= list(header='a',body='b')
a
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
boundary = try(which(vEmail=="")[1], silent=TRUE)
if (!is.na(boundary)){
eHead = vEmail[1:(boundary-1)]
eBod = vEmail[-(1:boundary)]
ret =  as.list(header = eHead,body=eBod)
return  (ret)
}
else
stop()
}
msg
head(msg)
eHead
severHeader(msg)
severHeader(msg)
severHeader =
# seperate header and body. Delimiter is first occurance of blank line.
# @vEmail a character vector wiht one entry per line of text
# return list of 2 char vectors (header=1, body =2) or null if no header/body found
function(vEmail){
boundary = -1 # default for failure
boundary = try(which(vEmail=="")[1], silent=TRUE)
if (!is.na(boundary)){
eHead = vEmail[1:(boundary-1)]
eBod = vEmail[-(1:boundary)]
ret =  list(header = eHead,body=eBod)
return  (ret)
}
else
stop()
}
severHeader(msg)
a=severHeader(msg)
a
findAttachments =
# Remove attachments from the body fo text. Content-type of 'multipart/mixed'
# indicates an attachment is present. BOUNDARY key contains delimitng text string for attachemtn boundaries.
# accepts a list of length 2 containing the head and the body
function(vHeader)  {
# search header for Content-Type: key
intContentLine = grep('content-type:',vHeader,ignore.case=TRUE)
if (intContentLine>0){
# found it. Then check the value is multipart.
if (grep('multipart',vHeader[intContentLine],ignore.case = TRUE)>0)
return (TRUE)
else
return (FALSE)
}
else
{
return (FALSE)
}
}
findAttachments(msg)
findAttachments(msg)
grep("multipart",msg,ignore.case = TRUE)
if (grep("multipart",msg,ignore.case = TRUE)>0) TRUE
a = grep("multipart",msg,ignore.case = TRUE)
a
a==0
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
findAttachments(msg)
vHeader[47L]
vHeader[46L]
findAttachments(msg)
grep('multipart',vHeader[46],ignore.case = TRUE)
grep('multipart',vHeader[46],ignore.case = TRUE)>0
if (grep('multipart',vHeader[46],ignore.case = TRUE)>0) print "TRUE"
findAttachments =
# Remove attachments from the body fo text. Content-type of 'multipart/mixed'
# indicates an attachment is present. BOUNDARY key contains delimitng text string for attachemtn boundaries.
# accepts a list of length 2 containing the head and the body
function(vHeader)  {
# search header for Content-Type: key
intContentLine = grep('content-type:',vHeader,ignore.case=TRUE)
if (intContentLine>0){
# found it. Then check the value is multipart.
if (grep('multipart',vHeader[intContentLine],ignore.case = TRUE)[1]>0)
return (TRUE)
else
return (FALSE)
}
else
{
return (FALSE)
}
}
findAttachments(msg)
# remove attachments
findAttachments =
# Remove attachments from the body fo text. Content-type of 'multipart/mixed'
# indicates an attachment is present. BOUNDARY key contains delimitng text string for attachemtn boundaries.
# accepts a list of length 2 containing the head and the body
function(vHeader)  {
# search header for Content-Type: key
intContentLine = grep('content-type:',vHeader,ignore.case=TRUE)
if (intContentLine>0){
# found it. Then check the value is multipart.
if (length(grep('multipart',vHeader[intContentLine],ignore.case = TRUE))>0)
return (TRUE)
else
return (FALSE)
}
else
{
return (FALSE)
}
}
findAttachments(msg)
a= grep("aaa","dddvvvaaa")
class(a)
lenght(a)
length(a)
a= grep("x","dddvvvaaa")
class(a)
length(a)
class(sampleEmails)
lapply(sampleEmails, function(x) grep("BOUNDARY",x))
lapply(sampleEmails, function(x) grep("BOUNDARY",x,ignore.case = TRUE))
length(sampleEmails)
sampleEmails[[6]]
sampleEmails[[5]]
lapply(sampleEmails, function(x) grep("BOUNDARY",x,ignore.case = TRUE))
lapply(sampleEmails, function(x) grep("BOUNDARY",x,ignore.case = TRUE))
a=severHeader(sampleEmails)
a=lapply(sampleEmails, severHeader)
length(a)
class(a)
a[[1]]
a[[1]]$header
a[[9]]$header
a[[6]]$header
lapply(a, findAttachments(x) grep('boundary',x$header,ignore.case = TRUE)
lapply(a, findAttachments(x) grep('boundary',x$header,ignore.case = TRUE))
lapply(a, function(x) grep('boundary',x$header,ignore.case = TRUE))
lapply(a, function(x) findAttachments(x$header))
lapply(a, function(x) findAttachments(x$header))
findAttachments(a[[7]]$header)
a[[1]]$header
function(vHeader)  {
# search header for Content-Type: key
intContentLine = grep('content-type:',vHeader,ignore.case=TRUE)[1]
if (intContentLine>0){
# found it. Then check the value is multipart.
if (length(grep('multipart',vHeader[intContentLine],ignore.case = TRUE))>0)
{
# get the delimiting string
strDelimiter = sub(".*boundary=\"(.*)\";.*","\\1",vHeader[intContentLine])
return (list(TRUE,strDelimiter))
}
else
return (list(FALSE,""))
}
else
{
return (list(FALSE,""))
}
}
findAttachments(a[[7]]$header)
grep('content-type:',a[[1]]$header,ignore.case=TRUE)[1]
if (grep('content-type:',vHeader,ignore.case=TRUE)[1])>0)
grep('content-type:',vHeader,ignore.case=TRUE)[1])>0
grep('content-type:',vHeader,ignore.case=TRUE)[1]>0
grep('content-type:',a[[1]]$header,ignore.case=TRUE)[1]>0
c = grep('content-type:',a[[1]]$header,ignore.case=TRUE)[1]>0
c
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
vHeader
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
flagAttachments = lapply(splitSample, function(x) findAttachments(x$header))
source('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
flagAttachments
splitSample[[7]]$header
splitSample[[6]]$header
flagAttachments[[1]]
flagAttachments[[6]]
flagAttachments[[7]]
flagAttachments[[8]]
flagAttachments[[9]]
flagAttachments[[10]]
flagAttachments[[11]]
sampleEmails[[11]]$header
splitSample[[11]]$header
function(vHeader)  {
# search header for Content-Type: key
intContentLine = grep('content-type:',vHeader,ignore.case=TRUE)[1]
if (length(intContentLine)>0){
# found it. Then check the value is multipart.
if (length(grep('multipart',vHeader[intContentLine],ignore.case = TRUE))>0)
{
# get the delimiting string
# strDelimiter = sub(".*boundary=\"(.*)\";.*","\\1",vHeader[intContentLine])  # failed as values for cntenttype key can wrap around lines and quotes mayb be missing
# find the boundary key
intBoundaryLoc = grep("boundary=",vHeader) #boundary token line number
# remove quotes and then extract the boundary token value.
strTemp = gsub("\"","",vHeader[intBoundaryLoc])
strDelimiter = sub(".*boundary=([^;]+);?.*","\\1",strTemp)
return (list(TRUE,strDelimiter))
}
else
return (list(FALSE,""))
}
else
{
return (list(FALSE,""))
}
}
splitSample[[6]$header]
splitSample[[6]]$header
)
flagAttachments = lapply(splitSample, function(x) findAttachments(x$header))
flagAttachments
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
splitSample[[11]]$body
messagePaths
sampleSplit[[15]]
splitSample[[15]]
flagAttachments[[11]]
splitSample[[11]]$body
splitSample[[10]]$body
dropAttachments =
# remove attachments based on information boundary string data passed in
# lAttachInfo tuple (flag,boundary string)
# lBody single email bodies corresponding to the flag data
function(lAttachInfo, lBody){
if (!lAttachInfo$blHasAttachment)
stop()
else
{
#find the location of the opening boundaries string occurence ("--"+strDelim)
strDelimOpen = paste("--",lAttachInfo$strDelim,sep="")
strDelimClose = paste(strDelimOpen,"--",sep="")
lOpenLocs = which(lBody==strDelimOpen)
lCloseLocs = which(lBody==strDelimClose)
# check that boundaries are properly applied by checking that email has one opening boundary at start of body
# at least one start of attachment and one close. If no opening one the format is faulty.
### special cases
# length(lOpenLocs)==1 & length(lCloseLocs)==1)  -> No attachment despite delimiters present. Assume no attachment
if (length(lOpenLocs)==1 & length(lCloseLocs)==1) {
lBody[lCloseLocs[[1]]] = NULL
lRet=lBody[-(1:lOpenLocs)]
}
else if (length(lOpenLocs)>1 & length(lCloseLocs)==0){
## opening delimiter but no closing. Assume everything after 2nd delimiter is an attachment.
lRet = lBody[-(lOpenLocs[[2]]:length(lBody))]
}
else
{
lRet = lBody[-(lOpenLocs[[2]]:lCloseLocs[[1]])]
}
return (lRet)
}
}
splitSampleNOAttach = mapply(flagAttachments,dropAttachments,splitSample$body)
splitSampleNOAttach = mapply(findAttachments,dropAttachments,splitSample$body)
length(dropAttachments())
length(flafAttachments)
length(flafAttachments)
length(flagAttachments)
splitSampleNOAttach = mapply(dropAttachments,flagAttachments, splitSample$body)
length(splitSample$body)
splitSample = lapply(sampleEmails, severHeader)
flagAttachments = lapply(splitSample, function(x) findAttachments(x$header))
source('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
length(splitSample)
length(flagAttachments)
splitSampleNOAttach = mapply(dropAttachments,flagAttachments, splitSample$body)
dropAttachments(flagAttachments[[11]],splitSample[[11]]$body)
splitSampleNOAttach = mapply(dropAttachments,flagAttachments, splitSample$body)
dropAttachments(flagAttachments[[11]],splitSample[[11]]$body)
dropAttachments(flagAttachments[[11]],splitSample[[11]]$body)
dropAttachments(flagAttachments[[11]],splitSample[[11]]$body)
dropAttachments(flagAttachments[[11]],splitSample[[11]]$body)
dropAttachments(flagAttachments[[11]],splitSample[[11]]$body)
dropAttachments(flagAttachments[[11]],splitSample[[11]]$body)
lCloseLocs[[1]]
class(lBody)
lBody[lCloseLocs[[1]]]
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
}
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
dropAttachments =
# remove attachments based on information boundary string data passed in
# lAttachInfo tuple (flag,boundary string)
# lBody single email bodies corresponding to the flag data
function(lAttachInfo, vBody){
if (!lAttachInfo$blHasAttachment)
stop()
else
{
#find the location of the opening boundaries string occurence ("--"+strDelim)
strDelimOpen = paste("--",lAttachInfo$strDelim,sep="")
strDelimClose = paste(strDelimOpen,"--",sep="")
lOpenLocs = which(vBody==strDelimOpen)
lCloseLocs = which(vBody==strDelimClose)
# check that boundaries are properly applied by checking that email has one opening boundary at start of body
# at least one start of attachment and one close. If no opening one the format is faulty.
### special cases
# length(lOpenLocs)==1 & length(lCloseLocs)==1)  -> No attachment despite delimiters present. Assume no attachment
if (length(lOpenLocs)==1 & length(lCloseLocs)==1) {
vRet = vBody[-lCloseLocs[[1]]]
vRet=vRet[-(1:lOpenLocs)]
}
else if (length(lOpenLocs)>1 & length(lCloseLocs)==0){
## opening delimiter but no closing. Assume everything after 2nd delimiter is an attachment.
vRet = vBody[-(lOpenLocs[[2]]:length(lBody))]
}
else
{
vRet = vBody[-(lOpenLocs[[2]]:lCloseLocs[[1]])]
}
return (vRet)
}
}
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
splitSample = lapply(sampleEmails, severHeader)
flagAttachments = lapply(splitSample, function(x) findAttachments(x$header))
splitSampleNOAttach = mapply(dropAttachments,flagAttachments, splitSample$body)
splitSampleNOAttach = mapply(dropAttachments,flagAttachments, splitSample)
splitSampleNOAttach = mapply(dropAttachments,flagAttachments, splitSample)
debugSource('~/Documents/GitRepos/RRepos/Spam/Spam.R', echo=TRUE)
